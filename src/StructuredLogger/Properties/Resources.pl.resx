<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
 <data name="OutputItemParameterMessagePrefix" xml:space="preserve">
<value>Elementy wyjściowe: </value>
</data>
<data name="ProjectImportSkippedEmptyFile" xml:space="preserve">
<value>Projekt „{0}” nie został zaimportowany przez projekt „{1}” o ({2},{3}), ponieważ plik był pusty.</value>
</data>
<data name="TaskFound" xml:space="preserve">
<value>Używanie zadania „{0}” z zestawu „{1}”.</value>
</data>
<data name="ToolsVersionInEffectForBuild" xml:space="preserve">
<value>Kompilowanie przy użyciu wersji narzędzi „{0}”.</value>
</data>
<data name="OverridingTarget" xml:space="preserve">
<value>Zastępowanie elementu docelowego „{0}” w projekcie „{1}” elementem docelowym „{2}” z projektu „{3}”.</value>
</data>
<data name="TargetSkippedWhenSkipNonexistentTargets" xml:space="preserve">
<value>Element docelowy „{0}” został pominięty. Element docelowy nie istnieje w projekcie, a parametr SkipNonexistentTargets ma wartość true.</value>
</data>
<data name="ProjectImportSkippedFalseCondition" xml:space="preserve">
<value>Projekt „{0}” nie został zaimportowany przez projekt „{1}” o ({2},{3}) z powodu niespełnionego warunku; ({4}) oceniono jako ({5}).</value>
</data>
<data name="ProjectImportSkippedNoMatches" xml:space="preserve">
<value>Projekt „{0}” nie został zaimportowany przez projekt „{1}” o ({2},{3}) z powodu braku zgodnych plików.</value>
</data>
<data name="SearchPathsForMSBuildExtensionsPath" xml:space="preserve">
<value>Ścieżki wyszukiwania dla elementu {0}: {1}</value>
</data>
<data name="TaskParameterPrefix" xml:space="preserve">
<value>Parametr zadania:</value>
</data>
<data name="DuplicateImport" xml:space="preserve">
<value>MSB4011: Nie można ponownie zaimportować pliku „{0}”. Został on już zaimportowany w „{1}”. Najprawdopodobniej jest to błąd kompilacji. Ten kolejny import zostanie zignorowany. {2}</value>
</data>
<data name="TargetAlreadyCompleteFailure" xml:space="preserve">
<value>Pominięto element docelowy „{0}”. Wcześniejsza kompilacja nie powiodła się.</value>
</data>
<data name="General.OverridingProperties" xml:space="preserve">
<value>Przesłanianie globalnych właściwości projektu „{0}” przy użyciu następujących wartości:</value>
</data>
<data name="ItemGroupRemoveLogMessage" xml:space="preserve">
<value>Usunięte elementy: </value>
</data>
<data name="ProjectImported" xml:space="preserve">
<value>Importowanie projektu „{0}” do projektu „{1}” o ({2},{3}).</value>
</data>
<data name="PropertyGroupLogMessage" xml:space="preserve">
<value>Ustaw właściwość: {0}={1}</value>
</data>
<data name="General.AdditionalProperties" xml:space="preserve">
<value>Dodatkowe właściwości projektu „{0}”:</value>
</data>
<data name="TargetDoesNotExistBeforeTargetMessage" xml:space="preserve">
<value>Element docelowy „{0}” wymieniony w atrybucie BeforeTargets na pozycji „{1}” nie istnieje w projekcie, dlatego będzie ignorowany.</value>
</data>
<data name="TaskFoundFromFactory" xml:space="preserve">
<value>Używanie zadania „{0}” na podstawie fabryki zadań „{1}”.</value>
</data>
<data name="ProjectImportSkippedMissingFile" xml:space="preserve">
<value>Projekt „{0}” nie został zaimportowany przez projekt „{1}” w lokalizacji ({2},{3}), ponieważ plik nie istniał.</value>
</data>
<data name="TargetSkippedFalseCondition" xml:space="preserve">
<value>Pominięto element docelowy „{0}” z powodu fałszywego warunku; ({1}) oszacowano jako ({2}).</value>
</data>
<data name="TaskSkippedFalseCondition" xml:space="preserve">
<value>Pominięto zadanie „{0}” z powodu fałszywego warunku; ({1}) oszacowano jako ({2}).</value>
</data>
<data name="ItemGroupIncludeLogMessagePrefix" xml:space="preserve">
<value>Dodane elementy: </value>
</data>
<data name="OutputPropertyLogMessage" xml:space="preserve">
<value>Właściwość wyjściowa: {0}={1}</value>
</data>
<data name="ProjectImportSkippedInvalidFile" xml:space="preserve">
<value>Projekt „{0}” nie został zaimportowany przez projekt „{1}” w lokalizacji ({2},{3}), ponieważ plik był nieprawidłowy.</value>
</data>
<data name="TargetAlreadyCompleteSuccess" xml:space="preserve">
<value>Pominięto element docelowy „{0}”. Wcześniejsza kompilacja powiodła się.</value>
</data>
<data name="TryingExtensionsPath" xml:space="preserve">
<value>Próba zaimportowania elementu {0} przy użyciu ścieżki rozszerzeń {1}</value>
</data>
<data name="PropertyReassignment" xml:space="preserve">
<value>Ponowne przypisanie właściwości: $({0})=„{1}” (poprzednia wartość: „{2}”) w {3}</value>
</data>
<data name="General.GlobalProperties" xml:space="preserve">
<value>Właściwości globalne:</value>
</data>
<data name="General.UndefineProperties" xml:space="preserve">
<value>Usuwanie właściwości:</value>
</data>
<data name="ResolveAssemblyReference.UnifiedPrimaryReference" xml:space="preserve">
<value>Zunifikowane odwołanie podstawowe „{0}”.</value>
</data>
<data name="ResolveAssemblyReference.AssemblyFoldersExSearchLocations" xml:space="preserve">
<value>Lokalizacja klucza rejestru AssemblyFoldersEx: „{0}”</value>
</data>
<data name="GetSDKReferenceFiles.ConflictReferenceDifferentSDK" xml:space="preserve">
<value>Wystąpił konflikt dwóch odwołań, które dotyczą tej samej nazwy pliku w zestawach SDK „{0}” i „{1}”. Wybrano plik „{2}” zamiast pliku „{3}”, ponieważ został on rozpoznany jako pierwszy.</value>
</data>
<data name="ResolveAssemblyReference.Dependency" xml:space="preserve">
<value>Zależność „{0}”.</value>
</data>
<data name="ResolveAssemblyReference.PrimaryReference" xml:space="preserve">
<value>Odwołanie podstawowe „{0}”.</value>
</data>
<data name="Copy.HardLinkComment" xml:space="preserve">
<value>Tworzenie twardego łącza w celu skopiowania „{0}” do „{1}”.</value>
</data>
<data name="Copy.DidNotCopyBecauseOfFileMatch" xml:space="preserve">
<value>Nie wykonano kopiowania z pliku „{0}” do pliku „{1}”, ponieważ parametr „{2}” w projekcie został ustawiony na wartość „{3}”, a rozmiary plików i sygnatury czasowe pasują do siebie.</value>
</data>
<data name="ResolveAssemblyReference.SearchPath" xml:space="preserve">
<value>Dla ścieżki wyszukiwania SearchPath „{0}”.</value>
</data>
<data name="ResolveAssemblyReference.UnifiedDependency" xml:space="preserve">
<value>Zunifikowana zależność „{0}”.</value>
</data>
<data name="GetSDKReferenceFiles.ConflictReferenceSameSDK" xml:space="preserve">
<value>Wystąpił konflikt dwóch odwołań, które dotyczą tej samej nazwy pliku rozpoznanej w zestawie SDK „{0}”. Wybrano plik „{1}” zamiast pliku „{2}”, ponieważ został on rozpoznany jako pierwszy.</value>
</data>
<data name="GetSDKReferenceFiles.ConflictRedistDifferentSDK" xml:space="preserve">
<value>Wystąpił konflikt dwóch plików z folderu redystrybucyjnego, które mają taką samą ścieżkę docelową „{0}” w zestawach SDK „{1}” i „{2}”. Wybrano plik „{3}” zamiast pliku „{4}”, ponieważ został on rozpoznany jako pierwszy.</value>
</data>
<data name="Copy.FileComment" xml:space="preserve">
<value>Kopiowanie pliku z „{0}” do „{1}”.</value>
</data>
</root>